// Copyright 2005-2011 Virtutech AB
dml 1.2;

device afdxES;

parameter desc = "afdx End System";
parameter documentation = "afdx End System";
parameter byte_order = "big-endian"; 
 
import "utility.dml";
import "io-memory.dml";
import "simics/devs/memory-space.dml";
import "packet-frame.dml";
import "config-tables.dml";
import "vl.dml";
import "constant.dml";
import "unpacket_frame.dml";
import "afdx-exchange.dml";
import "pci-action.dml";
import "pci-register.dml";
//import "afdxES-register.dml";


header %{
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <errno.h>
    #include <unistd.h>
    #include <WINSOCK2.H>

    SOCKET client_socket;

    extern int socket_init(void);
    extern int socket_recv(unsigned char *recvbuf, int size);
    extern int socket_send(unsigned char *sendbuf, int size);
%}

extern int socket_init(void);
extern int socket_recv(char *recvbuf, int size);
extern int socket_send(char *sendbuf, int size);

footer %{
    int socket_init(void) {
        WSADATA wsa;

        if (WSAStartup(MAKEWORD(2,2), &wsa)) {
            fprintf(stderr, "WSAStartup failed, error code is %d.\n", WSAGetLastError());
            return -1;
        }

        client_socket = socket(AF_INET, SOCK_STREAM , 0);    

        if (client_socket  == INVALID_SOCKET) {
            fprintf(stderr, "Create socket failed, error code is %d.\n", WSAGetLastError());
            return -1;
        }

        SOCKADDR_IN serveraddr;   
        memset(&serveraddr, 0, sizeof(serveraddr));
        serveraddr.sin_family = AF_INET;
        serveraddr.sin_port = htons(9750);
        serveraddr.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");   

        if (connect(client_socket, (struct sockaddr *) &serveraddr, sizeof(serveraddr)) != 0) {
            fprintf(stderr, "Connect failed, error code is %d.\n", WSAGetLastError());
            return -1;
        }

        fprintf(stdout, "Socket_init ok\n");

        return 0;
    }

    int socket_send(unsigned char *sendbuf, int size) {
        int len = send(client_socket, (char *)sendbuf, size, 0);

        if (len == size) {
            fprintf(stdout, "Socket send sucessfully, send %d bytes.\n", len);
            return len;
        } else {
            fprintf(stderr, "Socket send failed, size = %d, sended len = %d!\n", size, len);
            return 0;
        }
    }

    int socket_recv(unsigned char *recvbuf, int size) {
        fd_set rfds;
        FD_ZERO(&rfds);                
        FD_SET(client_socket, &rfds);  

        struct timeval tv = {0};             

        int retval = select(0, &rfds, NULL, NULL, &tv);   
        if (retval == -1) {
            fprintf(stderr, "Socket recv select failed, error code is %d\n.", WSAGetLastError());
            return -1;
        }
        else if (retval == 0) {
            return 0;
        } else {
            int len = 0;

            if (FD_ISSET(client_socket, &rfds)) {
                memset(recvbuf, 0, size);

                len = recv(client_socket, (char *)recvbuf, size, 0);
                if (len == size) {
                    fprintf(stdout, "Socket recv sucessfully!\n", WSAGetLastError());
                } else {
                    fprintf("Socket recv failed, error code is %d.\n", WSAGetLastError());
                }
            }

            return len;
        }
    }
%}

connect local_space 
{
    parameter documentation = "The local-space the device uses to send/receive"
        + "data to/from PCI memory space.";
    parameter configuration = "optional";
    interface memory_space 
	{
        parameter c_type = "memory_space_interface_t";
    }
}

connect phy0 
{
	parameter documentation = "Send data to ARINC664 2";
    parameter configuration = "optional";
    interface data_exchange 
	{
        parameter c_type = "data_exchange_interface_t";
    }
}

implement data_exchange 
{
	method send_frame(uint8 *data, uint32 size) 
	{
		log "info" : "called by ARINC2 ";
		call $unpacket_frame(data, size);
	}
}


attribute mode "Used to switch work mode" { // 0 and 1
    parameter allocate_type = "uint32";
}

method socket_loop_recv() {
    local int length;
    local uint8 *buf = new uint8 [PORT_DATA_SIZE];
    length = socket_recv(buf, PORT_DATA_SIZE);
    
    if (length > 0) {
        local exception_type_t exn;
		exn = $local_space.memory_space.access_simple($dev.obj,
                                                      $pci9056.dmaladr0.ladr0,
                                                      buf,
                                                      length,
                                                      Sim_RW_Write,Sim_Endian_Target);
        
        log "info", 4 : "Read from the port cache, then write to local space";
        if (exn != Sim_PE_No_Exception) 
            log "error": "unknown exception (%d) on local space read", cast (exn, int);

        delete buf;             // notice
    } else {
        after (1) call $socket_loop_recv();
    }
}

// USER-TODO: Add init() and post_init() methods here, if needed.
// init() will be run to set the empty state of the model, before any
// configuration or checkpointed attributes are set.  post_init() is run after
// all configuration attributes have been set.  This happens both when the
// initial configuration is set and when the configuration is loaded from a
// checkpoint.
method post_init() 
{
	call $pci_config.update_all_mappings();   //测试需要，暂时先注释掉
    memset($udp_first,1,PORT_SIZE);
    if ($mode == 1) {
        socket_init();
        call $socket_loop_recv();
    }
}
